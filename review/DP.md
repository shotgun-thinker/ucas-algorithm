# 动态规划

## 知识归纳

将一个问题拆成若干个更小规模的子问题集，求解这些子问题，找到不同规模的子问题之间的推演规律，从而从小规模的情形推断出大规模问题的解。

### 适用的问题

1. 可以将大问题拆分为若干个小规模问题。
2. 上述的拆分具有==最优子结构的性质==：大问题的最优解可以由小问题的最优解推出。
3. 上述的拆分具有==无后效性==：一旦`f(n)`确定，`f(n)`的生成过程就不再重要，对之后的问题没有影响。即：给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

动态规划问题必然是一个多步决策的问题，每次的决策将使得问题的规模缩小。假设每次进行一次都会进入一下个“状态”，可以断言：

1. 每个阶段的最优状态都是由==上一个阶段的最优状态==得到的；
2. 每个阶段的最优状态是由之前所有阶段的状态的组合得到的；

### 类型

#### 0-1 Knapsack Problem

> 背包的承重为$W$，$n$个物品的集合 $I=\{I_1,I_2,...,I_n\}$，其中第$i$个物品$I_i$的重量是 $w_i$，价值是 $v_i$。求 $I$ 的子集 $I'$，使得 $I'$ 中的物体在总重量不超过 $W$ 的前提下，总价值最大。

分析：假设在任意一步决策中，选择剩余物品（记作 $S$）选择一个物品 $I_i$，剩余重量减少 $w_i$，当然要求减去 $w_i$ 后依然大于0，否则重量就溢出了。如果没有任何一个物品可以选择，那么就返回0，作为递归的终止。
$$
OPT(S,w)=
\left\{
	\begin{array}{l}
		\mathop{max}\limits_{I_i \in S, w_i \le w} \{v_i+OPT(S \backslash \{I_i\},w-w_i)\}	
		& \text{if } \exists I_i \in S, w_i \le w\\
		0 & \text{otherwise}
	\end{array}
\right.
$$
改进：上述方法中，每一步决策围绕“选择哪件物品”展开，但如果物品集合很大的话，上述方法的时间复杂度颇高，需要改进。以下方法围绕“是否选择第 $i$ 件物品展开”，具体说来就是：

1. 在一步决策中，选择是否选择第 $i$ 个物件，只有两种选择，分别是“选”和“不选。如果决定“选”，需要减去当前物品的重量，那么递归进入 $OPT(i-1, w-w_i)$；如果决定“不选”，剩余重量不变，则进入 $OPT(i-1,w)$。
2. 接下来讨论哪些情况不能“选”：如果当前物品的重量比剩余重量还大，那就不能“选”。
3. 最后讨论递归终止条件：当 $i=0$，即为最后一件物品，或者 $w=0$，即无剩余重量时，返回0。

$$
OPT(i,w)=
\left\{
	\begin{array}{l}
		0 & \text{if } i=0 \text{ or } w=0\\
		OPT(i-1,W) & \text{if } w \le w_i \\
		max\{OPT(i-1,w),v_i+OPT(i-1,w-w_i)\} & \text{otherwise}
	\end{array}
\right.
$$

#### 完全背包问题

> 背包的承重为$W$，$n$个物品的集合 $I=\{I_1,I_2,...,I_n\}$，其中第$i$个物品$I_i$的重量是 $w_i$，价值是 $v_i$。求 $I'$，使得 $I'$ 中的物体在总重量不超过 $W$ 的前提下，总价值最大，每个物品可以使用无限次。

#### LIS

#### LCS

#### 区间模型

#### 树状模型

## 作业

### 1. Money Robbing

情况二：假设当围成圈时最大抢劫金钱数为$f_c(A)$, $A$为存储给定的一列房子的金钱数量的向量，$A[i]$表示第$i$个房子的金钱，$A[j,k]$表示第$j$到第$k$个房子的金钱向量（包括第 $j$ 个和第 $k$ 个房子）。‘
$$
f_c(n)=max(f(A[1:n-1])+A[0],~f(A[1:n]))
$$

### 5. Toys Buildings

> 现在有一排的玩具房子，它们有不同的高度，用列表`A`存储，假设`A=[4, 2, 6, 3, 9]`。每次操作可以选择其中连续的房子，令它们的高度加一。比如选择`[2, 6, 3]`这个连续子区间进行操作，操作后`A=[4, 3, 7, 4, 9]`。求进行最少的操作，使得这排房子从左到右高度递增（非严格单调增）。

假设`A=[4, 2, 6, 3, 9]`，由于我们最终需要元素值从左到右递增，而第二个元素小于第一个元素，我们希望进行两次操作，使得第二个元素与第一个元素相等，即通过两次操作后，`A=[4, 4, 6, 3, 9]`，此时第三个元素大于第二个元素，则略过这个元素。再对第四个元素进行操作，使其等于6……最终`A=[4, 4, 6, 6, 9]`。此种进行，总操作次数为5。

上述操作是逐个元素进行操作，那如果选取若干个连续元素进行操作呢？比如一开始，对第二和第四个元素进行操作，则`A=[4,4,8,5,9]`；然后单独对第四个元素进行操作三次，得到`A=[4, 4, 8, 8, 9]`，总操作次数仍然为5。不难观察到：==对一个选定子区间进行操作，该区间内的单调性不改变，且元素两两间的差值不改变==。

似乎进行单个操作和区间操作的效果是相同的，但当我们考虑如下例子时，或许会有些不同：`A=[4, 2, 6, 3, 1]`。在这个例子中，当我们进行操作然后得到`A=[4, 4, 6, 6, 1]`时，我们发现还需要对第五个元素进行5次操作才足够，而如果在操作第四个元素时，我们顺便让第五个元素一起加，就可以少进行三次操作。

综上，我们找出了一个贪心算法策略：每次进行操作时，都将需要操作的数，连同其后面的所有元素一同操作。以`A=[4, 2, 6, 3, 1]`举例：

~~~python
A=[4, 2, 6, 3, 1]
A=[4, 4, 8, 5, 3]	# 对第二个元素及其后面的元素进行操作（2次）
A=[4, 4, 8, 8, 6]	# 对第四个元素及其后面的元素进行操作（3次）
A=[4, 4, 8, 8, 8]	# 对第五个元素及其后面的元素进行操作（2次）
# 总操作次数：7次
~~~

## OJ

### 1. Triangle

动态规划要求问题的规模不断变小，而在这题中，问题的规模显然是“三角形的层数”。从 trivial case 开始入手：我们假设这个三角形只有3个元素，比如`[3, 5, 6]`，那么最短的路径显然是`3->5`，因为另一条路径`3->6`的和要更大。再让层数加一，如果三角形有6个元素：`[1, 2, 3, 4, 5, 6]`，最小路径很显然是`1->2->4`。

~~~
  1
 2 3
4 5 6
~~~

我们发现，除了最底层的元素外，所有的元素都有两个下层元素可供选择，而我们总会选更小的那个元素。比如当我们确定路径为`1->2`后，那么最后一个数一定不选5而是选4。由此，我们不妨从底层往上推进：当我们处理这个三角形的第二和第三层的时候，我们可以确定只有两种路径：`2->4`和`3->5`，前者的和为6，后者的和为8，那么上述的三角形就可以简化为：

~~~
 1
6 8
~~~

显然路径为`1->6`，所以最小路径和为7。

### 2. Maximum Alternating Subsequence Sum

> 这题暂时没想明白，忘了当时咋想的了

这题不好直接分析，但知道是动态规划类型的题后，我们可以先假设我们从数组的第一个数开始逐一遍历，选择或不选择其中的若干个数。假设某一时刻我们已经选择了其中的k个数，即`[n1, n2, ... nk]`，假设这个数组中奇数索引的元素和为`odd`，偶数索引的元素和为`even`，那么根据题意，`result = even - odd`。然后考虑：是否将后一个数加入进来？为此，我们需要分情况讨论（假设这个数为`num`）：

1. 如果 k 是偶数：即 k+1 是奇数，那么如果我们选择这个数，就必须确保`even - num > odd`，否则选了这个数之后`result`就变小了。
2. 如果 k 是奇数：即 k+1 是偶数，那么如果我们选择这个数，就要确保`odd + num > even`，否则选了这个数之后`result`就变小了。