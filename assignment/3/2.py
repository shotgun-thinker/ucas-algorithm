# [Job Schedule]
# There are n distinct jobs, labeled J1, J2, . . . , Jn, which can be performed completely independently
# of one another. Each jop consists of two stages: first it needs to be preprocessed on
# the supercomputer, and then it needs to be finished on one of the PCs.
# Let’s say that job Ji needs pi seconds of time on the supercomputer, followed by fi seconds
# of time on a PC.
# Since there are at least n PCs available on the premises, the finishing of the jobs can be
# performed on PCs at the same time. However, the supercomputer can only work on a single
# job a time without any interruption. For every job, as soon as the preprocessing is done on the
# supercomputer, it can be handed off to a PC for finishing.
# Let’s say that a schedule is an ordering of the jobs for the supercomputer, and the completion
# time of the schedule is the earliest time at which all jobs have finished processing on the PCs.
# Give a polynomial-time algorithm that finds a schedule with as small a completion time as
# possible.

def jobSchedule():
    pass
