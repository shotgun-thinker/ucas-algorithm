# Divde and Conquer

## 知识归纳

#### 基本思想

将规模为N的问题分解为k个相互独立的子问题，这些子问题与原问题类型相同；将这些子问题再次分解成若干个独立的子问题，直至子问题的规模足够小；当子问题规模足够小后，对问题进行求解，再将解合并为原问题的解。

用分治求解问题是通常用递归的方式，因为递归型比较清晰。但实际上任何的递归都可以转化为迭代的形式，而且任何算法的递归型的开销都比迭代型要高（额外的开销来自于调用栈）。

#### 适用分治法求解的问题的特征

1. **自顶向下求解** - 该问题的规模缩小到一定程度时可以轻易地解决。
2. **最优子结构性质** - 该问题可以分解为若干个规模较小的相同问题。
3. **子问题合并求解** - 利用该问题分解出的子问题的解可以合并为该问题的解。
4. **子问题相互独立性** - 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

### 分治法求解问题的步骤

1. **分解 (divide)**：将原问题分解成若干个规模较小，相互独立，与原问题形式相同的子问题。
2. **解决 (conquer)**：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。
3. **合并 (merge)**：将各个子问题的解合并为原问题的解。

### Master Theorem (主定理)

在分治中，若一个规模为 $n$ 的实例归约成 $a$ 个子实例，每个子实例规模都相同（设为 $\frac{n}{b}$），则时间复杂度 $T(n)$ 可表示为：
$$
\begin{equation}
    T(n)=
    \begin{cases}
    	1 & \text{if}~n=1\\
    	aT(\frac{n}{b})+O(n^d) & \text{otherwise}
    \end{cases}
\end{equation}
$$
其中 $a>1$, $b>1$, $d>0$. 则 $T(n)$ 的上界可表示为：

1. 当 $d<log_ba$ 时，有$T(n)=O(n^{log_ba})$;
2. 当 $d=log_ba$ 时，有$T(n)=O(n^{log_ba}logn)$;
3. 当 $d>log_ba$ 时，有$T(n)=O(n^d)$.

在主定理中，$O(n^d)$ 为将 $a$ 个子问题的解合并的时间复杂度，即**分解**与**合并**这两步的合时间复杂度，一般**分解**的时间复杂度为$O(1)$，所以这里还是主要看$合并$的时间复杂度。

## 作业

> 之前 Assignment 中做过的题不细讲。

### 1. k最大问题

[Leetcode 215: Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

可以采用类似快排的方法，在数组中随机选择一个数作为`pivot`，然后将数组中小于`pivot`的数放在其的左边（左部），大于或等于`pivot`的数放在其右边（右部），然后分以下三种情况：

1. 如果右部元素个数大于 $k$，则继续在右部中寻找第 $k$ 大的数；
2. 如果右部数量恰好等于$k-1$，则`pivot`就是所求值；
3. 否则：在左部中寻找第 $k-x-1$ 大的数，其中 $x$ 为右部元素个数，1代表`pivot`。

当 `low=high` 时进行解决，返回对应的数。（此处可以进行优化：当出现 `k=high-low+1` 时进行解决，返回指定区间中最小的数）

> 时间复杂度：因为是快排的思想，所以时间复杂度是 $O(nlogn)$。
>
> 空间复杂度：包含递归，调用栈平均深度为 $logn$，每一个栈项内无新开辟的空间，故为 $O(logn)$。

### 2. 二叉树找局部最小问题

由于给定的是完全二叉树，所以还是比较好考虑的。假设解决函数为 $F(T)$，其中 $T$ 为给定树的根节点。大致思路是从给定的根节点开始扫描，对于每个节点进行如下讨论：

1. 若无子节点，则节点为叶节点，故必然为**局部最小（local minimum）**，返回此节点。
1. 若所有子节点的值都大于本节点，则本节点必然为**局部最小**，返回此节点。
2. 若有子节点 $C$ 的值小于本节点，则本节点不可能为**局部最小**，而 $C$ 可能为局部最小，则运行 $F(C)$。

> 这道题有个奇怪的地方是，它只需要返回一个**局部最小**，而非全部，难不成默认只有一个局部最小？
>
> 时间复杂度：$O(logn)$
>
> 空间复杂度：只有开辟二叉树的空间 $O(n)$

### 3. 最大连续子序列和问题

[Leetcode 53: Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

（这题是完全可以用动态规划做的，因此考试大概率不会出。）

### 4. 目标值区间问题

[Leetcode 34: Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 5. 多边形分解问题

这题用到了卡特兰数，如式（2）所示。思路是将一个多边形按照其中的一个三角形（有很多种取三角形的可能）分成左右两部分（两个子问题），分治解决。
$$
h(n)=\sum_{i=0}^{n-1}{h(i)h(n-i-1)}
$$

这里注意套公式时，上述公式中的$n$为给定的多边形变数减2。

正确性证明：

> （1）如果n=3，即三角形，计算的结果为3，算法正确。
>
> （2）假设n=k时算法是正确的，现证n=k+1时算法仍然正确：

### 6. 链表合并问题

[Leetcode 23: Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

这题思路很简单，将 k 个有序链表列表分为两部分（每部分 $\frac{k}{2}$ 个）（两个子问题）。当两部分各只有一个有序列表时，将其合并。（合并两个有序链表需要掌握）。

> 时间复杂度：合并两个有序链表的时间复杂度为$O(m+n)$，其中 $m$ 和 $n$ 分别是两个链表的长度。题目中说每个列表的长度为 $n$，故该部分为 $O(n)$；合并次数为 $O(klogk)$ 次，相乘得到：$O(knlogk)$。
>
> 空间复杂度：包含递归，调用栈平均深度为 $logk$，每一个栈项内开辟了长度为 $O(k)$ 的数组，故为 $O(klogk)$。

![img](https://pic.leetcode-cn.com/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png)

对于如何分（divide），有两种不同的策略：

1. 将`lists`从中间切开前后两段，然后对两段分别进行递归
2. 遍历`lists`，第一轮合并`list0`和`list`、`list2`、`list3`，以此类推；第二轮按照同样的方法合并第一轮已经合并好的链表。

上图使用的是方法2（即力扣中的分治方法），而方法2是要优于方法1的，因为方法1可能导致更多“落单”的列表。就如上图的例子，一共有6个列表，如果从中间切分，那就是`[0, 1, 2]`和`[3, 4, 5]`，显然两边各有一个落单的列表。

## OJ

### 1. Fast Mod Exponentiation

[Fast Mod Exponentiation](http://124.16.71.58:81/problem/93)

[leetcode 372: Super Pow](https://leetcode.com/problems/super-pow/)

这是一道偏数学应用的编程题。我们知道 $ab\%k=(a\%k)(b\%k)%k$。
$$
a^{12345}\%k=(a^{12340}\%k)*(a^5\%k)=[(a^{1234}\%k)^{10}\%k]*(a^5\%k)\%k
$$
观察上面这组实例不难发现，当 $b$ 很大时，可以通过类似转换，将 $b$ 拆分为个位和前面一串数，然后再通过递归解决。设一串整数为 $m$, $m_i$ 表示 $m$ 的第 $i$ 位数，$m_{1,i}$ 表示 $m$ 的第1位（最高位）到第 $i$ 位数组成的整数。则：
$$
a^{m_{1,i}}\%k=[(a^{m_{1,i-1}}\%k)^{10}\%k]*(a^{m_i}\%k)\%k
$$
设函数 $g(a,c)$ 返回 $(a^c\%k)$ 的值，其中 $0 \le c \le 10$；函数 $f(a,b)$ 返回 $a^b\%k$ 的值，通过式（4）可得：
$$
f(a,b)=g(f(a,b[:-1]),10)*g(a,b[-1])\%k
$$

> 这道题有很多方法，我认为这种方法是比较接近分治思想的。用欧拉定理做的其实很危险，万一到时候人家给的不是1337就麻烦了。
>
> 时间复杂度：先确定 $n$ 为数组 $b$ 的长度。$g(a,c)$ 的时间复杂度为 $O(c)$，然而与 $n$ 无关，故看作 $O(1)$。$f(a,b)$ 中涉及递归，调用栈的最大深度为 $n$，故总时间复杂度为 $O(n)$。
>
> 空间复杂度：$O(n)$。 

### 2. First and Last Position Search

[First and Last Position Search](http://124.16.71.58:81/problem/94)

[Leetcode 34: Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

同作业的第4题相同。
